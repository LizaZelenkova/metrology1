SLOC+
Самой элементарной метрикой является количество строк кода (SLOC).
Кроме SLOC к количественным характеристикам относят также:
количество пустых строк,
количество комментариев,
процент комментариев (отношение числа строк, содержащих комментарии к общему количеству строк, выраженное в процентах),
среднее число строк для функций (классов, файлов),
среднее число строк, содержащих исходный код для функций (классов, файлов),
среднее число строк для модулей.



Холстед +
Основу метрики Холстеда составляют четыре измеряемых характеристики программы:
n1 - число уникальных операторов программы, включая символы-
разделители, имена процедур и знаки операций (словарь операторов);
n2 - число уникальных операндов программы (словарь операндов);
N1 - общее число операторов в программе;
N2 - общее число операндов в программе.
Опираясь на эти характеристики, получаемые непосредственно при анализе исходных текстов программ, М. Холстед вводит следующие оценки:
словарь программы
n=n1+n2,
длину программы
N=N1+N2,                     (1)
объем программы
V=N*log2(n) (бит).           (2)
Под битом подразумевается логическая единица информации - символ, оператор, операнд.
Далее М. Холстед вводит n* - теоретический словарь программы, т.е. словарный запас, необходимый для написания программы, с учетом того, что необходимая функция уже реализована в данном языке и, следовательно, программа сводится к вызову этой функции. Например, согласно М. Холстеду, возможное осуществление процедуры выделения простого числа могло бы выглядеть так:
CALL SIMPLE (X,Y),
где Y - массив численных значений, содержащий искомое число X.
Теоретический словарь в этом случае будет состоять из
n1* : {CALL, SIMPLE (...)},
n1*=2; n2* : {X, Y},
n2*=2,
а его длина, определяемая как
n* = n1* + n2*,
будет равняться 4.
Используя n*, Холстед вводит оценку V*:
V* = n* * log2 n*,    (3)
с помощью которой описывается потенциальный объем программы, соответствующий максимально компактному тексту программы, реализующей данный алгоритм.
Следующие пять характеристик являются продолжением метрики Холстеда.
1. Для измерения теоретической длины программы N^ М. Холстед вводит аппроксимирующую формулу:
N^ = n1*log2(n1) + n2*log2(n2),        (6)
где n1 - словарь операторов; n2 - словарь операндов программы.
Вводя эту оценку, Холстед исходит из основных концепций теории информации, по аналогии с которыми частота использования операторов и операндов в программе пропорциональна двоичному логарифму количества их типов. Таким образом, выражение (6) представляет собой идеализированную аппроксимацию (1), т. е. справедливо для потенциально корректных программ, свободных от избыточности или несовершенств (стилистических ошибок). Несовершенствами можно считать следующие ситуации:
а) последующая операция уничтожает результаты предыдущей без их использования;
б) присутствуют тождественные выражения, решающие совершенно одинаковые задачи;
в) одной и той же переменной назначаются различные имена и т. п.
Подобные ситуации приводят к изменению N без изменения n.
М. Холстед утверждает, что для стилистически корректных программ отклонение в оценке теоретической длины N^ от реальной N не превышает 10%.
Мы предлагаем использовать N^ как эталонное значение длины программы со словарем n. Длина корректно составленной программы N, т. е. программы, свободной от избыточности и имеющей словарь n, не должна отклоняться от теоретической длины программы N^ более чем на 10%. Таким образом, измеряя n1, n2, N1 и N2 и сопоставляя значения N и N^ для некоторой программы, при более чем 10%-ном отклонении можно говорить о наличии в программе стилистических ошибок, т. е. несовершенств.
На практике N и N^ часто существенно различаются.
2. Другой характеристикой, принадлежащей к метрикам корректности программ, по М. Холстеду, является уровень качества программирования L (уровень программы):
L=V*/V,               (7)
где V и V* определяется соответственно выражениями (2) и (3).
Исходным для введения этой характеристики является предположение о том, что при снижении стилистического качества программирования уменьшается содержательная нагрузка на каждый компонент программы и, как следствие, расширяется объем реализации исходного алгоритма. Учитывая это, можно оценить качество программирования на основании степени расширения текста относительно потенциального объема V*. Очевидно, для идеальной программы L=1, а для реальной - всегда L<1.
3. Нередко целесообразно определить уровень программы, не прибегая к оценке ее теоретического объема, поскольку список параметров программы часто зависит от реализации и может быть искусственно расширен. Это приводит к увеличению метрической характеристики качества программирования. М. Холстед предлагает аппроксимировать эту оценку выражением, включающим только фактические параметры, т. е. параметры реальной программы:
L^ = 2*n2 / (n1*N2).
4. Располагая характеристикой L^, Холстед вводит характеристику I, которую рассматривает как интеллектуальное содержание конкретного алгоритма, инвариантное по отношению к используемым языкам реализации: I = L^ * V. (8)
На наш взгляд, да и по мнению самого автора, термин интеллектуальность не совсем удачен. Преобразуя выражение (8) с учетом (7), получаем
I = L^V = LV = V*V/V = V*.
Эквивалентность I и V* свидетельствует о том, что мы имеем дело с характеристикой информативности программы.
Введение характеристики I позволяет определить умственные затраты на создание программы. Процесс создания программы условно можно представить как ряд операций:
1) осмысление предложения известного алгоритма;
2) запись предложения алгоритма в терминах используемого языка программирования, т. е. поиск в словаре языка соответствующей инструкции, ее смысловое наполнение и запись.
Используя эту формализацию в методике Холстеда, можно сказать, что написание программы по заранее известному алгоритму есть N^-кратная выборка операторов и операндов из словаря программы n, причем число сравнений (по аналогии с алгоритмами сортировки) составит log2(n).
Если учесть, что каждая выборка-сравнение содержит, в свою очередь, ряд мысленных элементарных решений, то можно поставить в соответствие содержательной нагрузке каждой конструкции программы сложность и число этих элементарных решений. Количественно это можно характеризовать с помощью характеристики L, поскольку 1/L имеет смысл рассматривать как средний коэффициент сложности, влияющий на скорость выборки для данной программы. Тогда оценка необходимых интеллектуальных усилий по написанию программы может быть измерена как
E = N^ * log2(n/L).          (9)
Таким образом, E характеризует число требуемых элементарных решений при написании программы.
Однако следует заметить, что E адекватно характеризует лишь начальные усилия по написанию программ, поскольку при построении E не учитываются отладочные работы, которые требуют интеллектуальных затрат иного характера.
Суть интерпретации этой характеристики состоит в оценке не затрат на разработку программы, а затрат на восприятие готовой программы. При этом вместо теоретической длины программы N^ используется ее реальная длина:
                  E' = N * log2(n/L).
Характеристика E' введена исходя мз предположения, что интеллектуальные усилия на написание и восприятие программы очень близки по своей природе. Однако если при написании программы стилистические погрешности в тексте практически не должны отражаться на интеллектуальной трудоемкости процесса, то при попытке понять такую программу их присутствие может привести к серьезным осложнениям. Эта посылка достаточно хорошо согласуется с нашими выводами относительно взаимосвязи N и N^, изложенными выше.
Преобразуя формулу (9) с учетом выражений (2) и (7), получаем
                   E = V * V / V*.
Такое представление E', а соответственно и E, так как E=E', наглядно иллюстрирует целесообразность разбиения программ на отдельные модули, поскольку интеллектуальные затраты оказываются пропорциональными квадрату объема программы, который всегда больше суммы квадратов объемов отдельных модулей.


Маккейба
Впервые графическое представление программ было предложено Маккейбом. Основной метрикой сложности он предлагает считать цикломатическую сложность графа программы, или, как ее еще называют, цикломатическое число Маккейба, характеризующее трудоемкость тестирования программы.
Для вычисления цикломатического числа Маккейба Z(G) применяется формула
                   Z(G)=e-v+2p,
где e - число дуг ориентированного графа G;
v - число вершин;
p - число компонентов связности графа.
Число компонентов связности графа можно рассматривать как количество дуг, которые необходимо добавить для преобразования графа в сильно связный. Cильно связным называется граф, любые две вершины которого взаимно достижимы. Для графов корректных программ, т. е. графов, не имеющих недостижимых от точки входа участков и "висячих" точек входа и выхода, сильно связный граф, как правило, получается путем замыкания дугой вершины, обозначающей конец программы, на вершину, обозначающую точку входа в эту программу.
По сути Z(G) определяет число линейно независимых контуров в Сильно связном графе. Иначе говоря, цикломатическое число Маккейба показывает требуемое количество проходов для покрытия всех контуров сильно связного графа или количество тестовых прогонов программы, необходимых для исчерпывающего тестирования по критерию "работает каждая ветвь".
Для программы, граф которой изображен на рис.1, цикломатическое число при e=10, v=8, p=1 определится как Z(G)=10-8+2=4.
Цикломатическое число зависит только от количества предикатов, сложность которых при этом не учитывается. Например, имеется два оператора условия:
IF  X>0
THEN  X=A;
ELSE;
и
IF  (X>0 & FLAG='1'B)!
(X=0 & FLAG='0'B)
THEN  X=A;
ELSE;
Оба оператора предполагают единственное ветвление и могут быть представлены одним и тем же графом (рис. 2). Очевидно, цикломатическое число будет для обоих операторов одинаковым, не отражающим сложности предикатов, что весьма существенно при оценке программ.


Майерса
Исходя из этого Г. Майерс предложил расширение этой метрики. Суть подхода Г. Майерса состоит в представлении метрики сложности программ в виде интервала [Z(G), Z(G)+h]. Для простого предиката h=0, а для n-местных предикатов h=n-1. Таким образом, первому оператору соответствует интервал [2,2], а второму - [2,6].
По идее такая метрика позволяет различать программы, представленные одинаковыми графами. К сожалению, информация о результатах использования этого метода отсутствует, поэтому ничего нельзя сказать о его применимости.


Чепина
Суть метода состоит в оценке информационной прочности отдельно взятого программного модуля с помощью анализа характера использования переменных из списка ввода-вывода.
Все множество переменных, составляющих список ввода-вывода, разбивается на 4 функциональные группы :
1. P - вводимые переменные для расчетов и для обеспечения вывода.
Примером может служить используемая в программах лексического анализатора переменная, содержащая строку исходного текста программы, т.е. сама переменная не модифицируется, а только содержит исходную информацию.
2. M - модифицируемые, или создаваемые внутри программы переменные.
3. C - переменные, участвующие в управлении работой программного модуля (управляющие переменные).
4. T - не используемые в программе ("паразитные") переменные. Поскольку каждая переменная может выполнять одновременно несколько функций, необходимо учитывать ее в каждой соответствующей функциональной группе.
Далее вводится значение метрики Чепина :
Q = a1*P + a2*M + a3*C + a4*T,         (4)
где a1, a2, a3, a4 - весовые коэффициенты.
Весовые коэффициенты в выражении (4) использованы для отражения различного влияния на сложность программы каждой функциональной группы. По мнению автора метрики, наибольший вес, равный трем, имеет функциональная группа C, так как она влияет на поток управления программы. Весовые коэффициенты остальных групп распределяются следующим образом : a1=1, a2=2, a4=0.5. Весовой коэффициент группы T не равен 0, поскольку "паразитные" переменные не увеличивают сложность потока данных программы, но иногда затрудняют ее понимание. С учетом весовых коэффициентов выражение (4) принимает вид :
Q = P + 2M + 3C + 0.5T
Следует отметить, что рассмотренные метрики сложности программ основаны на анализе исходных текстов программ и графов, что обеспечивает единый подход к автоматизации из расчета.

спена
Определение спена основывается на локализации обращений к данным внутри каждой программной секции. Спен - это число утверждений, содержащих данный идентификатор, между его первым и последним появлением в тексте программы. Следовательно, идентификатор, появившийся n раз, имеет спен, равный n-1. При большом спене усложняется тестирование и отладка.

Джилба
Одной из наиболее простых, но, как показывает практика, достаточно эффективных оценок сложности программ является метрика Т. Джилба, в которой логическая сложность программы определяется как насыщенность программы выражениями типа IF-THEN-ELSE. При этом вводятся две характеристики: CL - абсолютная сложность программы, характеризующаяся количеством операторов условия; cl - относительная сложность программы, характеризующаяся насыщенностью программы операторами условия, т. е. cl определяется как отношение CL к общему числу операторов.
Используя метрику Джилба, мы дополнили ее еще одной составляющей, а именно характеристикой максимального уровня вложенности оператора CLI, что позволило не только уточнить анализ по операторам типа IF-THEN-ELSE, но и успешно применить метрику Джилба к анализу циклических конструкций.

МакКлура
Следующая метрика из данного класса — Метрика Мак-Клура. Выделяются три этапа вычисления данной метрики:
1. Для каждой управляющей переменной i вычисляется значениt её сложностной функции C(i) по формуле: C(i) = (D(i) * J(i))/n.
Где D(i) — величина, измеряющая сферу действия переменной i. J(i) — мера сложности взаимодействия модулей через переменную i, n — число отдельных модулей в схеме разбиения.
2. Для всех модулей, входящих в сферу разбиения, определяется значение их сложностных функций M(P) по формуле M(P) = fp * X(P) + gp * Y(P)
где fp и gp — соответственно, число модулей, непосредственно предшествующих и непосредственно следующих за модулем P, X(P) — сложность обращения к модулю P,
Y(P) — сложность управления вызовом из модуля P других модулей.
3. Общая сложность MP иерархической схемы разбиения программы на модули задаётся формулой:
MP = СУММА(M(P)) по всем возможным значениям P — модулям программы.
Данная метрика ориентирована на программы, хорошо структурированные, составленные из иерархических модулей, задающих функциональную спецификацию и структуру управления. Также подразумевается, что в каждом модуле одна точка входа и одна точка выхода, модуль выполняет ровно одну функцию, а вызов модулей осуществляется в соответствии с иерархической системой управления, которая задаёт отношение вызова на множестве модулей программы.
Также существует метрика, основанная на информационной концепции — мера Берлингера [8]. Мера сложности вычисляется как M=СУММАfi*log2pi, где fi — частота появления i-го символа, pi — вероятность его появления.
Недостатком данной метрики является то, что программа, содержащая много уникальных символов, но в малом количестве, будет иметь такую же сложность как программа, содержащая малое количество уникальных символов, но в большом количестве.